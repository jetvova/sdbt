// @generated
// This file was automatically generated by extracting instruction names, parameters, and bit
// patterns from the Armv8-A 2020-12, A64 Instruction Set Architecture documentation provided 
// in XML format. I believe this consitutes fair use for research and educational purposes.
// https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools

// Please note that the A64 instruction set is property and copyrighted material of Arm Ltd.

#![allow(unused_attributes, non_snake_case, non_camel_case_types)]
#![rustfmt::skip]

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Instruction {
	{{~#each instructions}}
    {{name}} {{~#if parameters}} { {{~#each parameters}} {{name}}: {{data_type}},{{~/each}} }
    {{~/if}},
  	{{~/each}}

    UNKNOWN(u32),
}

impl Instruction {
    // Primitive decoding mechanism through repetetive if checking. To be improved later
    pub fn decode(opcode: u32) -> Self {
        {{~#each instructions}}
        if opcode & {{hex identification.mask}} == {{hex identification.value}} {{~#each constraints}} && (opcode & {{hex mask}} != {{hex value}}) {{~/each}} {
            return Self::{{name}}
            {{~#if parameters}} {
                {{~#each parameters}}
                {{name}}: ((opcode & {{hex parameter_mask}}) >> {{low_bit}}) as {{data_type}},
                {{~/each}}
            }
            {{~/if}};
        }
        {{~/each}}
        
        Self::UNKNOWN(opcode)
    }

    pub fn encode(&self) -> u32 {
        match self {
            {{~#each instructions}}
            Self::{{name}} {{~#if parameters}} { {{~#each parameters}} {{name}},{{~/each}} }{{/if}} => {{hex identification.value}}
            {{~#if parameters}}
                {{~#each parameters}}
                | ((*{{name}} as u32) << {{low_bit}})
                {{~/each}}
            {{~/if}},
            {{~/each}}
            
            Self::UNKNOWN(opcode) => *opcode,
        }
    }
}

pub trait Decode {
    fn decode(&self) -> Instruction;
}

impl Decode for u32 {
    fn decode(&self) -> Instruction {
        Instruction::decode(*self)
    }
}    

#[cfg(test)]
mod tests {
    use super::*;

    {{~#each instructions}}
    #[test]
    fn roundtrip_{{name}}() {
        assert_eq!(Instruction::{{name}} {{~#if parameters}} { {{~#each parameters}} {{name}}: 0,{{~/each}} }{{/if}}.encode().decode(), 
                   Instruction::{{name}} {{~#if parameters}} { {{~#each parameters}} {{name}}: 0,{{~/each}} }{{/if}})
    }
    {{~/each}}

}